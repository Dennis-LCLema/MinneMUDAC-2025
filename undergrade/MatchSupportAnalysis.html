<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Match Support Contact Notes- Keyword Analysis Report</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="MatchSupportAnalysis_files/libs/clipboard/clipboard.min.js"></script>
<script src="MatchSupportAnalysis_files/libs/quarto-html/quarto.js"></script>
<script src="MatchSupportAnalysis_files/libs/quarto-html/popper.min.js"></script>
<script src="MatchSupportAnalysis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="MatchSupportAnalysis_files/libs/quarto-html/anchor.min.js"></script>
<link href="MatchSupportAnalysis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="MatchSupportAnalysis_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="MatchSupportAnalysis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="MatchSupportAnalysis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="MatchSupportAnalysis_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Match Support Contact Notes- Keyword Analysis Report</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="objective" class="level2">
<h2 class="anchored" data-anchor-id="objective">Objective</h2>
<p>The goal of this analysis was to explore the open-text <em>Match Support Contact Notes</em> to identify patterns in language that may correlate with <em>Match Length</em> — the duration that a match between Big and Little stays active.</p>
<p>By analyzing the most common words in matches that last longer versus those that end earlier, we aimed to provide insights that could inform early risk detection and support strategies for BBBS coordinators.</p>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<p><strong>Data Source</strong>: We used the <code>Training.xlsx</code> dataset containing match metadata and support notes.</p>
<p><strong>Target Variable</strong>: <code>Match Length</code> (in months)</p>
<p><strong>Splitting Criteria</strong>:</p>
<ul>
<li>We divided the data into two groups based on the <em>median match length (29.7 months):</em></li>
</ul>
<pre><code>-    **Long Matches**: `Match Length ≥ 29.7 months` (n = 19,701)

-    **Short Matches**: `Match Length &lt; 29.7 months` (n = 19,644)</code></pre>
<p><strong>Text Processing</strong>:</p>
<ul>
<li><p>Extracted text from the <code>Match Support Contact Notes</code> column</p></li>
<li><p>Removed common stopwords (e.g., “the”, “and”)</p></li>
<li><p>Used <code>CountVectorizer</code> to compute word frequencies</p></li>
<li><p>Compared average word usage between long and short matches</p></li>
<li><p>To optimize memory, we sampled 1,000 notes from each group</p></li>
</ul>
<section id="key-findings" class="level3">
<h3 class="anchored" data-anchor-id="key-findings"><strong>Key Findings</strong></h3>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Top 10 Keywords in Long Matches:</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>match_type      long     short  difference
match       3.327865  2.743028    0.584838
little      2.815338  2.242499    0.572839
check       1.430244  1.072998    0.357246
person      0.616805  0.318139    0.298666
support     1.066248  0.804247    0.262001
bbbs        1.250541  1.030213    0.220327
time        1.470700  1.263786    0.206914
mec         2.272694  2.078756    0.193938
email       0.655414  0.468360    0.187054
https       0.385252  0.207004    0.178248</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Top 10 Keywords in Short Matches:</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>match_type       long     short  difference
development  0.451501  0.576379   -0.124878
concerns     0.772667  0.901437   -0.128769
pc           0.156759  0.292309   -0.135550
child        1.029221  1.165329   -0.136108
volunteer    0.495807  0.640820   -0.145013
ls           0.640382  0.854638   -0.214256
bs           1.404663  1.727763   -0.323100
mc           0.165621  0.518857   -0.353236
answer       1.755947  2.286974   -0.531027
question     1.713118  2.297116   -0.583998</code></pre>
</div>
</div>
<p>This analysis compares the average frequency of words used in Match Support Contact Notes between long matches (≥ 29.7 months) and short matches (&lt; 29.7 months). It shows which words were more common in each group and how much more often they appeared, helping us understand the kind of language associated with match longevity.</p>
<p><strong>What We Learned From the Notes:</strong></p>
<p>When we looked at the words used in the Match Support Contact Notes, some clear patterns started to show up:</p>
<p>Matches that last longer tend to have notes that feel more personal and meaningful. There’s more talk about the relationship itself, how the little is doing, how time is being spend together, and signs of regular thoughtful communication. On the other hand, shorter matches tend to have notes that feel less personal and lack specific details about what the match is doing together. Instead of rich descriptions or reflections, the notes often include short responses or brief answers.</p>
</section>
<section id="suggested-coordinator-questions-for-early-risk-detection" class="level3">
<h3 class="anchored" data-anchor-id="suggested-coordinator-questions-for-early-risk-detection">Suggested Coordinator Questions for Early Risk Detection:</h3>
<p>To help Big Brothers Big Sisters Twin Cities identify whether a match is at risk of closing in the next 3–6 months, we recommend a focused set of dropdown-style questions that coordinators can ask during Match Support Calls. These questions are based on:</p>
<ul>
<li><p>Patterns in Match Support Contact Notes</p></li>
<li><p>Structured fields such as match duration, age, and program type</p></li>
<li><p>Common keywords seen in long- vs short-lasting matches</p></li>
</ul>
<p><strong>General Check_In Question(Ask the Big and the Little):</strong></p>
<p>These questions are designed to help coordinators get a sense of how the match is going — how connected the Big and Little feel, how often they’re meeting, and whether they need any extra support. From our analysis, we saw that matches with strong engagement and communication tend to last longer, so these quick questions can help surface important insights early on.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Ask This…</strong></th>
<th><strong>Response Options</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>How did your last meeting go?</td>
<td>Great / Okay / We didn’t meet / Prefer not to say</td>
</tr>
<tr class="even">
<td>What did you two do together?</td>
<td>Talked / Played games / Did schoolwork / Went somewhere / Didn’t meet</td>
</tr>
<tr class="odd">
<td>Do you have anything planned for your next meeting?</td>
<td>Yes / Not yet / I’d like help with ideas</td>
</tr>
<tr class="even">
<td>Do you feel comfortable talking with your Big/Little?</td>
<td>Yes / Sort of / Not really</td>
</tr>
<tr class="odd">
<td>Is there anything you’re concerned about in the match?</td>
<td>No / A little / Yes – something serious</td>
</tr>
<tr class="even">
<td>Do you need any support from BBBS right now?</td>
<td>No / Yes – Help with scheduling / Yes – There’s a conflict / Yes – I’d like resources or ideas</td>
</tr>
</tbody>
</table>
<p><strong>Age-Based Goals setting(Optional Add-on):<br>
</strong>Our data shows that youth in matches range from age 10 and up. To better align support with developmental stages and promote consistency in meetings, BBBS could consider building a goal-setting system that matches can choose from and revisit over time:</p>
<p><strong>For Ages 10–13:</strong></p>
<ul>
<li><p>Focus on academic support, confidence-building, and new experiences</p></li>
<li><p>Example goals: “Improve a school subject,” “Try a new activity,” “Make a new friend”</p></li>
</ul>
<p><strong>For Ages 14–18:</strong></p>
<ul>
<li><p>Focus on personal growth, independence, and future planning</p></li>
<li><p>Example goals: “Explore a career interest,” “Develop a new skill,” “Create a personal project”</p></li>
</ul>
<p><strong>Why it helps:</strong><br>
Having structured, age-appropriate goals gives the match something to work toward together — making each meeting more purposeful. This structure can improve consistency, encourage closeness, and help the Big feel more confident about how to support the Little. It also ensures the match isn’t just a “greet and meet” dynamic, but something more intentional and growth-oriented.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>