<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Match Support Contact Notes- Keyword Analysis Report</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="MatchSupportAnalysis_files/libs/clipboard/clipboard.min.js"></script>
<script src="MatchSupportAnalysis_files/libs/quarto-html/quarto.js"></script>
<script src="MatchSupportAnalysis_files/libs/quarto-html/popper.min.js"></script>
<script src="MatchSupportAnalysis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="MatchSupportAnalysis_files/libs/quarto-html/anchor.min.js"></script>
<link href="MatchSupportAnalysis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="MatchSupportAnalysis_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="MatchSupportAnalysis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="MatchSupportAnalysis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="MatchSupportAnalysis_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Match Support Contact Notes- Keyword Analysis Report</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="objective" class="level2">
<h2 class="anchored" data-anchor-id="objective">Objective</h2>
<p>The goal of this analysis was to explore the open-text <em>Match Support Contact Notes</em> to identify patterns in language that may correlate with <em>Match Length</em> — the duration that a match between Big and Little stays active.</p>
<p>By analyzing the most common words in matches that last longer versus those that end earlier, we aimed to provide insights that could inform early risk detection and support strategies for BBBS coordinators.</p>
</section>
<section id="methodology" class="level2">
<h2 class="anchored" data-anchor-id="methodology">Methodology</h2>
<p><strong>Data Source</strong>: We used the <code>Training.xlsx</code> dataset containing match metadata and support notes.</p>
<p><strong>Target Variable</strong>: <code>Match Length</code> (in months)</p>
<p><strong>Splitting Criteria</strong>:</p>
<ul>
<li>We divided the data into two groups based on the <em>median match length (29.7 months):</em></li>
</ul>
<pre><code>-    **Long Matches**: `Match Length ≥ 29.7 months` (n = 19,701)

-    **Short Matches**: `Match Length &lt; 29.7 months` (n = 19,644)</code></pre>
<p><strong>Text Processing</strong>:</p>
<ul>
<li><p>Extracted text from the <code>Match Support Contact Notes</code> column</p></li>
<li><p>Removed common stopwords (e.g., “the”, “and”)</p></li>
<li><p>Used <code>CountVectorizer</code> to compute word frequencies</p></li>
<li><p>Compared average word usage between long and short matches</p></li>
<li><p>To optimize memory, we sampled 1,000 notes from each group</p></li>
</ul>
<section id="key-findings" class="level3">
<h3 class="anchored" data-anchor-id="key-findings"><strong>Key Findings</strong></h3>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Top 10 Keywords in Long Matches:</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>match_type      long     short  difference
match       3.327865  2.743028    0.584838
little      2.815338  2.242499    0.572839
check       1.430244  1.072998    0.357246
person      0.616805  0.318139    0.298666
support     1.066248  0.804247    0.262001
bbbs        1.250541  1.030213    0.220327
time        1.470700  1.263786    0.206914
mec         2.272694  2.078756    0.193938
email       0.655414  0.468360    0.187054
https       0.385252  0.207004    0.178248</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Top 10 Keywords in Short Matches:</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>match_type       long     short  difference
development  0.451501  0.576379   -0.124878
concerns     0.772667  0.901437   -0.128769
pc           0.156759  0.292309   -0.135550
child        1.029221  1.165329   -0.136108
volunteer    0.495807  0.640820   -0.145013
ls           0.640382  0.854638   -0.214256
bs           1.404663  1.727763   -0.323100
mc           0.165621  0.518857   -0.353236
answer       1.755947  2.286974   -0.531027
question     1.713118  2.297116   -0.583998</code></pre>
</div>
</div>
<p>This analysis compares the average frequency of words used in Match Support Contact Notes between long matches (≥ 29.7 months) and short matches (&lt; 29.7 months). It shows which words were more common in each group and how much more often they appeared, helping us understand the kind of language associated with match longevity.</p>
<p><strong>What We Learned From the Notes:</strong></p>
<p>When we looked at the words used in the Match Support Contact Notes, some clear patterns started to show up:</p>
<p>Matches that last longer tend to have notes that feel more personal and meaningful. There’s more talk about the relationship itself, how the little is doing, how time is being spend together, and signs of regular thoughtful communication. On the other hand, shorter matches tend to have notes that feel less personal and lack specific details about what the match is doing together. Instead of rich descriptions or reflections, the notes often include short responses or brief answers.</p>
</section>
<section id="suggested-coordinator-questions-for-early-risk-detection" class="level3">
<h3 class="anchored" data-anchor-id="suggested-coordinator-questions-for-early-risk-detection">Suggested Coordinator Questions for Early Risk Detection:</h3>
<p>To help Big Brothers Big Sisters Twin Cities better support matches — especially those that might be at risk of closing early — we’ve put together a thoughtful list of check-in questions. These are meant to be used during regular coordinator calls or surveys, and are designed to uncover what’s going well, what might be getting in the way, and how we can offer better support.</p>
<p>We combined questions based on:</p>
<ul>
<li><p>What the data is telling us (like time constraints being a top reason for closure)</p></li>
<li><p>What Bigs and Littles might be feeling but not saying</p></li>
<li><p>The need for a simple, non-repetitive way to check in</p></li>
</ul>
<p>The final list includes both open-ended questions that give people space to reflect and share, and scaled questions (rated 1 to 5) that are easier to track over time.</p>
</section>
<section id="questions-for-the-big-mentor" class="level3">
<h3 class="anchored" data-anchor-id="questions-for-the-big-mentor">Questions for the Big (Mentor)</h3>
<p>These questions are designed to check in on how things are going from the Big’s perspective — what’s working, where they might be struggling, and how supported they feel.</p>
<p><strong>Open-Ended Questions:</strong></p>
<ul>
<li><p>What’s been going well in your match lately? Any challenges?</p></li>
<li><p>Is anything going on in your personal life that might be affecting your ability to meet with your Little?</p></li>
<li><p>What kind of support would be most helpful for you right now?</p></li>
<li><p>In one word or sentence, how would you describe your relationship with your Little?</p></li>
<li><p>What do you think makes a match feel successful?</p></li>
<li><p>Have you noticed any growth or progress in your Little?</p></li>
<li><p>Are there any concerns about your Little’s behavior, well-being, or engagement?</p></li>
<li><p>What kind of support would help your Little grow or stay more engaged?</p></li>
<li><p>How often are you in touch with your BBBS program staff? What’s that relationship like?</p></li>
<li><p>What’s been the most meaningful part of your experience as a volunteer so far?</p></li>
</ul>
<p><strong>Scale-Based (1 = strongly disagree, 5 = strongly agree):</strong></p>
<ul>
<li><p>I feel like I understand my Little’s needs and personality</p></li>
<li><p>I feel that my match is going well</p></li>
<li><p>I expect changes to my schedule in the next few months.</p></li>
<li><p>I’m able to make time for my match consistently.</p></li>
<li><p>I feel comfortable interacting with my Little.</p></li>
</ul>
</section>
<section id="why-these-questions-matter" class="level3">
<h3 class="anchored" data-anchor-id="why-these-questions-matter">Why These Questions Matter</h3>
<p>This set of questions helps us look at the full picture — not just how often matches are meeting, but how they’re feeling about each other and the match overall.</p>
<p>By combining direct questions with a few simple rating scales, we can:</p>
<ul>
<li><p>Catch early signs of disconnection or stress</p></li>
<li><p>Track how matches change over time</p></li>
<li><p>Make it easier for staff to step in with the right support</p></li>
<li><p>Give Bigs and Littles a voice in how their match is going</p></li>
</ul>
<p>These questions are based on real data (like closure reasons and note patterns), but they’re also grounded in real people and experiences. The goal is simple: create space for honest conversation and offer support before a match gets too far off track.</p>
</section>
<section id="group-engagement-idea" class="level3">
<h3 class="anchored" data-anchor-id="group-engagement-idea">Group Engagement Idea</h3>
<p>Along with regular one-on-one check-ins, it could really help to create a monthly group session where Bigs and Littles come together to hang out, have fun, and connect with others in the program. These events don’t need to be anything fancy — just something low-key and welcoming, like games, creative activities, or small team challenges. Adding light incentives like snacks, prizes, or friendly competitions can make it even more fun and encourage participation.</p>
<p><strong>Why it matters:</strong></p>
<ul>
<li><p>It gives matches a chance to connect more regularly, even if their one-on-one meetings have slowed down</p></li>
<li><p>It helps build a sense of belonging and shared experience — they’re not in this alone.</p></li>
<li><p>It gives staff a natural, low-pressure way to observe how matches are doing.</p></li>
<li><p>It helps identify which matches are thriving and which might need a little more support.</p></li>
</ul>
<p>While data can tell us a lot about which matches might be at risk — through things like time gaps, language in notes, or survey responses — seeing those relationships in action adds an entirely different layer of insight. You can often feel the energy (or distance) between a Big and Little more clearly in person than on a spreadsheet. These group sessions give coordinators the opportunity to confirm what the data suggests, or even catch things that numbers might miss.</p>
<p>Bringing people together like this can strengthen relationships, increase consistency, and make matches feel more supported. When paired with thoughtful check-in questions, this kind of group engagement can go a long way in helping BBBS prevent early match closures — while also making the experience more fun and meaningful for everyone involved.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>